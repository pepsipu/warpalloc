# warpalloc
[![GitHub](https://img.shields.io/github/license/pepsipu/warpalloc.svg?style=for-the-badge)](https://github.com/pepsipu/warpalloc/blob/master/LICENSE.md)

Warpalloc was written in Assembly in order to bid farewell to "C clutter". Autogenerated machine code is slow compared to a handwritten and carefully optimized machine code, which is why warpmalloc outperforms it's competitors like jemalloc and ptmalloc. In addition to this sheer speed, warpalloc uses a new method of attaining memory called "preallocating". Preallocating requests memory from the operating system at the start of the program to save time during the program's functional execution. Warpalloc currently works with Assembly, C, and C++.

Warpalloc is similar to ptmalloc, which you may know as "malloc", but much faster. In fact, warpalloc performs about *300 times* faster than ptalloc.

![graph](https://i.imgur.com/p4gdW4D.png)

You can test it yourself by running "benchmark.py".

### Sounds cool? How do I use it?
Using Warpalloc is amazingly simple. Simply link the object file with your source file. For example, you can do this with gcc like so.

`gcc -m32 walloc.o main.c -no-pie`

If you'd like your IDE to recognize you are using external functions from a static library, you can either include warpalloc header file (walloc.h) or write the following at the top of your code.

```c
extern void* walloc(int size);
extern void prewalloc(int size);
extern void wfree(void *ptr);
```

Know that you *MUST* preallocating something, even if the preallocation is 0. It doesn't matter what you preallocate, since once the preallocated area ends, it will simply request more from the operating system, which can cost you time. You must preallocate before allocating or freeing.
